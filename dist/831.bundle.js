"use strict";(self.webpackChunkprobability=self.webpackChunkprobability||[]).push([[831],{831:(t,s,e)=>{e.r(s),e.d(s,{AlwaysHeadsCoin:()=>o,AlwaysTailsCoin:()=>c,Coin:()=>h,FairCoin:()=>a,Flipper:()=>l,FlipperContainer:()=>p,is_flip_result:()=>i,is_flip_sequence_result:()=>n});class r{stats={};get_total(){let t=0;return Object.keys(this.stats).forEach((s=>{t+=this.stats[s].count})),t}track_stat(t){this.stats[t]={count:0,percentage:0}}increment(t){Object.keys(this.stats).includes(t)||this.track_stat(t),this.stats[t].count+=1;const s=this.get_total();Object.keys(this.stats).forEach((t=>{this.stats[t].percentage=this.stats[t].count/s}))}get data(){return this.stats}}function i(t){return t&&"string"==typeof t.label}function n(t){return t&&Array.isArray(t.sequence)}class l{_weights;_labels;constructor(t,s){if(1!==t.reduce(((t,s)=>t+s)))throw new Error("Weights must sum to 1.0");if(t.length!==s.length)throw new Error("Weights and labels must have same length");this._weights=t,this._labels=s}get weights(){return this._weights}get labels(){return this._labels}flip_sequence(t){const s=[],e=new r;for(let r=0;r<t;r++){const t=this.flip();s.push(t),e.increment(t.label)}return{sequence:s,stats:e}}}class h extends l{constructor(t){super(t,["H","T"])}flip(){const t=Math.random();let s=0;for(const[e,r]of this._weights.entries())if(s+=r,t<=s)return{weight_index:e,label:this._labels[e]};return{weight_index:this._weights[this._weights.length-1],label:this._labels[this._weights.length-1]}}}class a extends h{constructor(){super([.5,.5])}}class o extends h{constructor(){super([1,0])}}class c extends h{constructor(){super([0,1])}}class p{_flippers;constructor(){this._flippers=[]}get flippers(){return this._flippers}push(t){this._flippers.push(t)}pop(){this._flippers.pop()}clear(){this._flippers=[]}flip_all(t=1){const s=[];return this._flippers.forEach((e=>{s.push(e.flip_sequence(t))})),s}choose_random(){const t=Math.random(),s=1/this._flippers.length;let e=0;for(const r of this._flippers)if(e+=s,t<=e)return r;return this._flippers[this._flippers.length-1]}flip_random(t=1,s=!1){if(0===this._flippers.length)return null;if(1===t)return this.choose_random().flip();if(s){const s={sequence:[],stats:new r};for(let e=0;e<t;e++){const t=this.choose_random().flip();s.sequence.push(t),s.stats.increment(t.label)}return s}return this.choose_random().flip_sequence(t)}summarize(){const t=this._flippers.length,s={};return this._flippers.forEach((t=>{const e=`[${t.weights.map((t=>t.toPrecision(2)))}]`;Object.keys(s).includes(e)?s[e]+=1:s[e]=1})),{num_flippers:t,weight_buckets:s}}}}}]);